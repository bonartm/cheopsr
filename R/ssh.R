#' List all or R specific modules available on CHEOPS
#'
#' @param ronly a logical value indicating if only R specifig modules should be returned
#'
#' @return a vector of module names
#' @export
cheops_modules <- function(ronly = TRUE){
  modules <- cheops_ssh("module -t avail")
  modules <- modules[-grep("/opt", modules, fixed = TRUE)]
  if (ronly){
    modules[grep("R/", modules)]
  } else {
    modules
  }
}

#' Install a package on the cluster
#'
#' @param package name of the package as a character string
#' @param module r module to be loaded
#' @param lib lib location on the cluster
#'
#' @return character vector of R console output
#' @export
cheops_install <- function(package,
                           module = getOption("cheopsr.module"),
                           lib = getOption("cheopsr.libloc")){
  cheops_script("install.sh")
  out <- cheops_ssh(paste("./tmp/install.sh", module, lib, package), TRUE, TRUE)
  return(out)
}

#' Install a package from github on the cluster
#'
#' @param repo name of the repository e.g. <user>/<reponame>
#' @param ref name of the branch
#' @param module r module to be loaded
#' @param lib lib location on the cluster
#'
#' @return character vector of R console output or error if ssh command failed or package name could not be found
#' @details the {\link[devtools]{devtools}} package has to be installed on the cluster
#' @seealso {\link[devtools]{install_github}}
#' @export
cheops_install_github <- function(repo, ref = "master",
                                  module = getOption("cheopsr.module"),
                                  lib = getOption("cheopsr.libloc")){
  cheops_script("install_github.sh")
  out <- cheops_ssh(paste("./tmp/install_github.sh", module, lib, repo, ref), TRUE, TRUE)
  out
}

#' List the users running SLURM jobs
#'
#' @return a table containing the currently running jobs
#' @export
cheops_jobs <- function(){
  user <- getOption("cheopsr.username")
  res <- cheops_ssh(paste("squeue -u",user))
  res <- read.table(textConnection(res), header = TRUE)
  return(res)
}

#' Cancel a running SLURM job
#'
#' @param id the id of the job
#'
#' @return a table containing the currently running jobs
#' @export
cheops_cancel <- function(id){
  cheops_ssh(paste0("scancel ", id))
  cheops_jobs()
}

#' Submit a sbatch job to the cluster
#'
#' @param name name of the job
#' @param rscript location of the r script file to be executed
#' @param options named list of cluster options generated by {\link[cheopsr]{cheops_slurmcontrol}}
#' @param module name of r module to be loaded
#' @param account name of the account to be charged
#' @param lib location of the r lib on the cluster
#'
#' @return a numeric job id
#' @export
cheops_submit <- function(jobname, rscript, options,
                          module = getOption("cheopsr.module"),
                          account = getOption("cheopsr.account"),
                          lib = getOption("cheopsr.libloc")){

  cheops_mkdir(paste0("./", jobname))
  script <- cheops_gen(jobname, options, module, account, lib)
  from <- tempfile(fileext = ".sh")
  writeLines(script, from)
  to <- paste0("./", jobname, "/job.sh")
  cheops_send(from, to)
  cheops_ssh(paste0("chmod +x ./",  jobname, "/job.sh"))


  cheops_send(rscript, paste0("./", jobname,"/", "script.R"))
  job <- cheops_ssh(paste0("sbatch ", jobname, "/job.sh"))
  job <- gsub("Submitted batch job ", "", job)
  return(as.numeric(job))
}

#' Options for a SLURM task
#'
#' @description
#' Generates a list of options to be used in {\link[cheopsr]{cheops_submit}}
#'
#' @param nodes Number of nodes between 1 - 128
#' @param tasks Number of tasks \strong{per} node
#' @param mem Memory per node as a string (e.g. "4gb")
#' @param time Wall time of the job in the format "hh:mm:ss"
#'
#' @return a named list of options
#' @export
cheops_slurmcontrol <- function(nodes, tasks, mem, time, partition = NULL){
  opt <- list(nodes = nodes,
       "ntasks-per-node" = tasks,
       mem = mem,
       time = time)
  if(!is.null(partition)){
    opt <- c(opt, partition = partition)
  }
  return(opt)
}



#' Get a log file from a submitted job
#'
#' @param jobname the name of the job
#'
#' @return a raw character vector containing the lines of the log file
#' @export
cheops_getlog <- function(jobname){
  from <- paste0("./", jobname, "/log.out")
  to <- tempfile()
  tryCatch(
    cheops_get(from, to),
    warning = function(w) stop("File could not be found or other error.", call. = FALSE)

  )
  readLines(to)
}

#' Restore a single R Object from the cluster
#'
#' @param file location of the .rds file on the cluster
#'
#' @return the file
#' @export
cheops_readRDS <- function(file){
  to <- tempfile(fileext = ".rds")
  tryCatch(
    cheops_get(from, to),
    warning = function(w) stop("File could not be found or other error.", call. = FALSE)

  )
  readRDS(to)
}

#' Read in a table file from the cluster
#'
#' @param file location of the .txt or .csv file on the cluster
#' @param ... additional arguments passed to {\link[utils]{read.table}}
#'
#' @return
#' @export
cheops_readtable <- function(file, ...){
  to <- tempfile(fileext = ".txt")
  tryCatch(
    cheops_get(from, to),
    warning = function(w) stop("File could not be found or other error.", call. = FALSE)

  )
  read.table(file = to, ...)
}



